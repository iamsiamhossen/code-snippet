/**
* Author: iamsiamhossen
**/
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#define fastread() (ios_base::sync_with_stdio(0), cin.tie(0))
#define endl "\n"
#define int long long
#define float double
//HighLoad
#define ll long long int
#define pb push_back
#define ld long double
#define pi pair<ll, ll>
#define map map<int,int>
#define setd set<int, greater<int> >
#define seta set<int> 
//next three are handy ways to get ints, it's also force you to use '&' sign
#define GET1(a) scanf("%d", &a) 
#define GET2(a, b) scanf("%d%d", &a, &b)
#define GET3(a, b, c) scanf("%d%d%d", &a, &b, &c)
#define GETS(x) scanf("%s", x) //get a char* string
#define INIT1(n) LL (n); scanf("%lld", &(n)) 
#define INIT2(n, m) LL (n), (m); scanf("%lld%lld", &(n), &(m))
#define INIT3(n, m, k) LL (n), (m), (k); scanf("%lld%lld%lld", &(n), &(m), &(k))
#define YES cout<<"YES\n"
#define NO cout<<"NO\n"
#define Yes cout<<"Yes\n"
#define No cout<<"No\n"
#define Ok cout <<"Ok\n"
//Vector
#define vec vector<ll>;
#define vvi vector<vi>;
//Vector Pair
#define vectorpair vector<ii>;
#define vvii vector<vii>;
//MOD
#define EPS 1e-9
#define PI 3.1415926535897932384626433832795
#define MOD 1000000007
#define INF 1001001001
//for map, pair
#define mp make_pair
#define fi first
#define se second
#define forn (long long i = 0; i < long long(n); i++)
#define all(x) (x).begin(), (x).end()
// directions
const int fx[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}};
const int fxx[8][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}};
#define checkmate return 0;
using namespace __gnu_pbds;
using namespace std;
template <typename T> using pbds = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
 //Divisors 
//vector<int> divisors(int n)
//  {
//      vector<int> x;
//      for (int i = 1; 1ll * i * i <= n; i++)
//      {
//          if (n % i == 0)
//          {
//              x.push_back(i);
//              if (n / i != i)
//                  x.push_back(n / i);
//          }
//      }
//       sort(x.begin(), x.end());
//      return x;
//  }
 
// Sieve of Eratosthenes
// vector<int> isprime(int n)
// {
//     vector<bool> prime(n + 1, true);
//     prime[0] = prime[1] = false; // 0 and 1 are not prime numbers
//     for (int i = 2; i * i <= n; i++)
//     {
//         if (prime[i])
//         {
//             for (int j = i * i; j <= n; j += i)
//             {
//                 prime[j] = false;
//             }
//         }
//     }
//     vector<int> primes;
//     for (int i = 2; i <= n; i++)
//     {
//         if (prime[i])
//         {
//             primes.push_back(i);
//         }
//     }
//     return primes;
// }
 
//Prime Factorization
    // map<int, int> m;
    // for (int i = 2; i * i <= n; i++)
    // {
    //     if (n % i == 0)
    //     {
    //         while (n % i == 0)
    //         {
    //             m[i]++;
    //             n /= i;
    //         }
    //     }
    // }
    // if (n > 1)
    //     m[n]++;
 
//Check Prime
//bool isprime(int N){
    //if(N<2 || (!(N&1) && N!=2))
        //return false;
   // for(int i=3; i*i<=N; i+=2){
        //if(!(N%i))
           // return false;
   // }
   // return true;
//}
 
//LCM
// int lcm(int x1, int x2)
// {
//     return ((x1 * x2) / __gcd(x1, x2));
// }
 
void solve() {
    
}
int32_t main(){
    fastread();
    int tc = 1;
    cin >> tc;
    for (int t = 1; t <= tc; t++)
    {
        // cout << "Case " << t << ": ";
        solve();
    }
    checkmate;
}
